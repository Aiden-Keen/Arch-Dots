import{f as g}from"./chunk-7R3NEG4N.js";import{jc as S}from"./chunk-TAPPRV2Q.js";import{b as W}from"./chunk-MVNJOY5H.js";import{Nb as M,Sa as C}from"./chunk-KLKDJF5S.js";import{a as o,i as u,n as c}from"./chunk-WKJYWAXG.js";u();c();var E=M({authRepository:g,queryClient:S});u();c();var P=new C(W,g,E);u();c();u();c();u();c();var f=o(n=>`sq:doc:value:${n}`,"valueKeyFor"),y=o(n=>`sq:doc:refCount:${n}`,"refCountKeyFor"),l=o(n=>`sq:doc:refIds:${n}`,"refIdsKeyFor"),m=o(n=>`sq:doc:updatedAt:${n}`,"updatedAtKeyFor"),p=o(n=>`sq:doc:queue:${n}`,"queueKeyFor"),x=50,N=1e3*60*60*24;var v=class{static{o(this,"AsyncQueryStore")}isWriter;delegate;sendMessage;messageQueue=[];queues=new Map;queueProcessorPromise;resolveQueueWait;constructor(e){this.isWriter=e.isWriter,this.delegate=e.delegate;let{sendMessage:s}=e.connect(this.handleMessage.bind(this));if(this.sendMessage=s,this.isWriter){if(!this.delegate)throw new Error("Writer must have a delegate");this.startQueueProcessor()}}handleMessage(e){this.isWriter&&this.enqueueMessage(e)}enqueueMessage(e){this.messageQueue.push(e),this.resolveQueueWait&&(this.resolveQueueWait(),this.resolveQueueWait=void 0)}startQueueProcessor(){this.queueProcessorPromise=this.processQueue()}async processQueue(){for(;;){for(;this.messageQueue.length===0;)await new Promise(s=>{this.resolveQueueWait=s});let e=this.messageQueue.shift();try{await this.processMessage(e)}catch(s){console.error("Error processing message:",s)}}}async processMessage(e){switch(e.type){case"saveQuery":await this.writerSaveQuery(e.queryDefId,e.queryKey,e.value,e.updatedAt,e.refIds);break;case"saveEntity":await this.writerSaveEntity(e.entityKey,e.value,e.refIds);break;case"activateQuery":await this.writerActivateQuery(e.queryDefId,e.queryKey);break}}async loadQuery(e,s,t){if(!this.delegate)return;let r=await this.delegate.getNumber(m(s));if(r===void 0||r<Date.now()-(e.cache?.gcTime??N))return;let i=await this.delegate.getString(f(s));if(i===void 0)return;let a=await this.delegate.getBuffer(l(s));return a!==void 0&&await this.preloadEntities(a,t),this.activateQuery(e,s),{value:JSON.parse(i),refIds:a===void 0?void 0:new Set(a??[]),updatedAt:r}}async preloadEntities(e,s){if(this.delegate)for(let t of e){let r=await this.delegate.getString(f(t));if(r===void 0)continue;let i=JSON.parse(r);s.setPreloadedEntity(t,i);let a=await this.delegate.getBuffer(l(t));a!==void 0&&await this.preloadEntities(a,s)}}saveQuery(e,s,t,r,i){let a={type:"saveQuery",queryDefId:e.id,queryKey:s,value:t,updatedAt:r,refIds:i?Array.from(i):void 0};this.isWriter?this.enqueueMessage(a):this.sendMessage(a)}saveEntity(e,s,t){let r={type:"saveEntity",entityKey:e,value:s,refIds:t?Array.from(t):void 0};this.isWriter?this.enqueueMessage(r):this.sendMessage(r)}activateQuery(e,s){let t={type:"activateQuery",queryDefId:e.id,queryKey:s};this.isWriter?this.enqueueMessage(t):this.sendMessage(t)}async writerSaveQuery(e,s,t,r,i){await this.setValue(s,t,i?new Set(i):void 0),await this.delegate.setNumber(m(s),r),await this.writerActivateQuery(e,s)}async writerSaveEntity(e,s,t){await this.setValue(e,s,t?new Set(t):void 0)}async writerActivateQuery(e,s){if(!await this.delegate.has(f(s)))return;let t=this.queues.get(e);if(t===void 0){let a=x;t=await this.delegate.getBuffer(p(e)),t===void 0?(t=new Uint32Array(a),await this.delegate.setBuffer(p(e),t)):t.length!==a&&(t=new Uint32Array(t.buffer,0,a),await this.delegate.setBuffer(p(e),t)),this.queues.set(e,t)}let r=t.indexOf(s);if(r>=0){if(r===0)return;t.copyWithin(1,0,r),t[0]=s;return}let i=t[t.length-1];t.copyWithin(1,0,t.length-1),t[0]=s,i!==0&&(await this.deleteValue(i),await this.delegate.delete(m(i)))}async setValue(e,s,t){let r=this.delegate;await r.setString(f(e),JSON.stringify(s));let i=l(e),a=await r.getBuffer(i);if(t===void 0||t.size===0){if(await r.delete(i),a!==void 0)for(let h=0;h<a.length;h++){let d=a[h];await this.decrementRefCount(d)}}else{let h=new Uint32Array(t);if(a!==void 0)for(let d=0;d<a.length;d++){let A=a[d];t.has(A)?t.delete(A):await this.decrementRefCount(A)}for(let d of t)await this.incrementRefCount(d);await r.setBuffer(i,h)}}async deleteValue(e){let s=this.delegate;await s.delete(f(e)),await s.delete(y(e));let t=await s.getBuffer(l(e));if(await s.delete(l(e)),t!==void 0)for(let r of t)r!==0&&await this.decrementRefCount(r)}async incrementRefCount(e){let s=this.delegate,t=y(e),i=(await s.getNumber(t)??0)+1;await s.setNumber(t,i)}async decrementRefCount(e){let s=this.delegate,t=y(e),r=await s.getNumber(t);if(r===void 0)return;let i=r-1;i===0?await this.deleteValue(e):await s.setNumber(t,i)}};var Q=class{static{o(this,"ChromeExtensionPersistentStore")}async has(e){let s=await chrome.storage.local.get(e);return e in s}async getString(e){let t=(await chrome.storage.local.get(e))[e];return t===void 0?void 0:String(t)}async setString(e,s){await chrome.storage.local.set({[e]:s})}async getNumber(e){let t=(await chrome.storage.local.get(e))[e];return t===void 0?void 0:Number(t)}async setNumber(e,s){await chrome.storage.local.set({[e]:s})}async getBuffer(e){let t=(await chrome.storage.local.get(e))[e];if(t!==void 0&&Array.isArray(t))return new Uint32Array(t)}async setBuffer(e,s){await chrome.storage.local.set({[e]:Array.from(s)})}async delete(e){await chrome.storage.local.remove(e)}};function b(n){let e=n.portName??"signalium-query-store";return s=>{if(n.isWriter)return chrome.runtime.onConnect.addListener(t=>{t.name===e&&t.onMessage.addListener(r=>{s(r)})}),{sendMessage:o(()=>{},"sendMessage")};{let t=chrome.runtime.connect({name:e});return{sendMessage:o(r=>{try{t.postMessage(r)}catch(i){console.error("Failed to send message to background:",i)}},"sendMessage")}}}}o(b,"createChromeExtensionConnection");var ee=o((n={isWriter:!1})=>new v({isWriter:n?.isWriter??!1,connect:b(n),delegate:n.isWriter?new Q:void 0}),"createChromeStorageStore");export{E as a,P as b,ee as c};
//# sourceMappingURL=chunk-MASTYD3E.js.map
